<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Graphviz YAML Editor & Animation Controls</title>
  <!-- Load required libraries -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/@hpcc-js/wasm@2.20.0/dist/graphviz.umd.js"></script>
  <script src="https://unpkg.com/d3-graphviz@5.6.0/build/d3-graphviz.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  <script src="https://unpkg.com/graphlib@2.1.8/dist/graphlib.min.js"></script>
  <script src="https://unpkg.com/graphlib-dot@0.6.4/dist/graphlib-dot.min.js"></script>
  <!-- Material Components Web CSS -->
  <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css">
  
  <!-- Load nunjucks directly so it is available globally -->
  <script src="https://unpkg.com/nunjucks@3.2.4/browser/nunjucks.js"></script>
  
  <style>
    body { margin: 0; }
    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    .editor, .preview {
      padding: 16px;
      overflow: auto;
    }
    .editor { width: 40%; border-right: 1px solid #ccc; }
    .preview { flex-grow: 1; }
    .dragbar {
      width: 5px;
      cursor: col-resize;
      background-color: #ddd;
    }
    .download-buttons {
      margin-top: 16px;
    }
    .download-buttons button {
      margin-right: 8px;
    }
  </style>
  
  <!-- Load RequireJS (only used here for Monaco) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
  <script>
require.config({
  paths: {
    'nunjucks': 'https://unpkg.com/browse/nunjucks@3.1.0/browser/nunjucks.js',
    'vs': 'https://unpkg.com/monaco-editor@0.33.0/min/vs'
  },
  shim: {
    'nunjucks': {
      exports: 'nunjucks'
    }
  }
});

require(['nunjucks'], function(nunjucksInstance) {
  nunjucks = nunjucksInstance;
});
  </script>
</head>
<body>
  <div class="container">
    <!-- Left: YAML Editor (using Monaco) -->
    <div class="editor" id="leftPane">
      <h2 class="mdc-typography--headline6">YAML Editor</h2>
      <div id="yamlEditor" style="height: 80vh;"></div>
      <br>
      <button id="updateYaml" class="mdc-button mdc-button--raised">
        <span class="mdc-button__label">Update YAML Now</span>
      </button>
    </div>

    <!-- Dragbar -->
    <div class="dragbar" id="dragbar"></div>
    
    <!-- Right: Preview Area -->
    <div class="preview">
      <div class="controls">
        <div class="mdc-select inline-control" id="previewModeSelect">
          <select id="previewMode" class="mdc-select__native-control">
            <option value="graph">Graph</option>
            <option value="animation">Animation</option>
          </select>
          <div class="mdc-line-ripple"></div>
        </div>
        <span id="selectionContainer" class="inline-control"></span>
        <span id="sliderContainer" style="display:none; margin-left: 16px;" class="inline-control">
          <label class="mdc-typography--body2" for="animSlider">Frame:</label>
          <input type="range" id="animSlider" min="0" max="0" value="0">
        </span>
      </div>
      
      <div id="animExtraControls" class="anim-extra-controls" style="display:none;">
        <button id="playBtn" class="mdc-button mdc-button--raised inline-control">
          <span class="mdc-button__label">Play</span>
        </button>
        <button id="pauseBtn" class="mdc-button mdc-button--raised inline-control">
          <span class="mdc-button__label">Pause</span>
        </button>
        <button id="stopBtn" class="mdc-button mdc-button--raised inline-control">
          <span class="mdc-button__label">Stop</span>
        </button>
        <button id="rewindBtn" class="mdc-button mdc-button--raised inline-control">
          <span class="mdc-button__label">Rewind</span>
        </button>
        <div class="mdc-form-field inline-control">
          <div class="mdc-checkbox">
            <input type="checkbox" id="loopCheckbox" class="mdc-checkbox__native-control">
            <div class="mdc-checkbox__background">
              <svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24">
                <path class="mdc-checkbox__checkmark-path" fill="none" stroke="white" d="M1.73,12.91 8.1,19.28 22.79,4.59"/>
              </svg>
              <div class="mdc-checkbox__mixedmark"></div>
            </div>
          </div>
          <label for="loopCheckbox">Loop</label>
        </div>
        <span class="inline-control">
          <label class="mdc-typography--body2" for="delaySlider">Delay (ms):</label>
          <input type="range" id="delaySlider" min="250" max="5000" value="1500">
          <span id="delayValue">1500</span>
        </span>
      </div>
      
      <div class="download-buttons">
        <button id="downloadDot" class="mdc-button mdc-button--raised">
          <span class="mdc-button__label">Download DOT</span>
        </button>
        <button id="downloadSvg" class="mdc-button mdc-button--raised">
          <span class="mdc-button__label">Download SVG</span>
        </button>
      </div>
      
      <div id="graph"></div>
    </div>
  </div>
  
  <!-- Application Scripts -->
  <script>
    // Helper functions for processing DOT text.
    function parseAttributes(attrStr) {
      if (!attrStr) return {};
      const attrs = {};
      const regex = /(\w+)\s*=\s*(<([\s\S]*?)>|"([^"]*)"|([^",\s]+))/g;
      let match;
      while ((match = regex.exec(attrStr)) !== null) {
        const key = match[1];
        const value = match[3] !== undefined ? match[3] :
                      match[4] !== undefined ? match[4] :
                      match[5];
        attrs[key] = value;
      }
      return attrs;
    }

    function stringifyAttributes(attrs) {
      const parts = [];
      for (let key in attrs) {
        parts.push(key + '="' + attrs[key] + '"');
      }
      return parts.join(", ");
    }

function preprocessDot(dotText) {
  console.log("Preprocessing DOT...", dotText);
  const globalRegex = /(\w+)\s*\[\s*([^\]]+?)\s*\]/g;
  let nodeDict = {};
  let match;
  while ((match = globalRegex.exec(dotText)) !== null) {
     let nodeName = match[1];
     let attrStr = match[2];
     nodeDict[nodeName] = {
         raw: attrStr,
         attrs: parseAttributes(attrStr)
     };
  }
  let effectiveCache = {};
  function computeEffectiveAttributes(nodeName) {
     if (effectiveCache[nodeName]) return effectiveCache[nodeName];
     let node = nodeDict[nodeName];
     if (!node) return {};
     let effective = {};
     if (node.attrs.inherit && node.attrs.inherit.trim() !== "") {
          let parents = node.attrs.inherit.split(",").map(s => s.trim());
          parents.forEach(parentName => {
             let parentEff = computeEffectiveAttributes(parentName);
             let inherited = Object.assign({}, parentEff);
             if (inherited.style === "invis") {
                delete inherited.style;
                if (inherited.real_style) inherited.style = inherited.real_style;
             }
             delete inherited.real_style;
             effective = Object.assign({}, effective, inherited);
          });
     }
     let ownAttrs = Object.assign({}, node.attrs);
     delete ownAttrs.inherit;
     effective = Object.assign({}, effective, ownAttrs);
     if (effective.style === "invis") delete effective.style;
     if ("real_style" in effective) {
         if (!("style" in effective)) effective.style = effective.real_style;
         delete effective.real_style;
     }
     effectiveCache[nodeName] = effective;
     return effective;
  }
  
  let replaced = dotText.replace(globalRegex, function(fullMatch, nodeName, attrStr) {
     let attrs = parseAttributes(attrStr);
     if (!attrs.inherit) return fullMatch;
     let effective = computeEffectiveAttributes(nodeName);
     let newAttrStr = stringifyAttributes(effective);
     return nodeName + " [ " + newAttrStr + " ]";
  });

  console.log("replaced...", replaced);
  return replaced;
}

        
    // Template and common code processing functions.
    let commons = [];
    let templateFunctions = [];
    
    function includeCommons(dot) {
      if (commons && commons.length > 0) {
        let commonCode = "";
        commons.forEach(c => {
          if (c.dot) {
            commonCode += c.dot + "\n";
          }
        });
        dot = commonCode + dot;
      }
      return dot;
    }

    function renderTemplatesInDot(dot) {
      console.log("Rendering templates in DOT...",dot);
      let context = {
include: function(graphName) {
  let importedDot = getGraphDot(graphName);
  if (!importedDot) {
    console.warn("Graph not found for include:", graphName);
    return "";
  }
  // Process the included graph content:
  importedDot = applyTemplateProcessing(importedDot);
  importedDot = preprocessDot(importedDot);
  
  // Unwrap an outer "digraph { ... }" or "graph { ... }" if present.
  let wrapperRegex = /^\s*(digraph|graph)\s*\{\s*([\s\S]*?)\s*\}\s*$/;
  let match = importedDot.match(wrapperRegex);
  if (match) {
    importedDot = match[2];
  }
  
  return importedDot;
}
      };
      context.import = context.include;

      if (Array.isArray(templateFunctions)) {
        templateFunctions.forEach(tmpl => {
          let parts = tmpl.name.split(".");
          if (parts.length === 2) {
            let ns = parts[0],
                funcName = parts[1];
            if (!context[ns]) {
              context[ns] = {};
            }
            context[ns][funcName] = function(...args) {
              let localContext = {};
              if (Array.isArray(tmpl.args)) {
                tmpl.args.forEach((argName, index) => {
                  localContext[argName] = args[index] || "";
                });
              }
              return nunjucks.configure({ autoescape: false }).renderString(tmpl.template, localContext);
            };
          } else {
            context[tmpl.name] = function(...args) {
              let localContext = {};
              if (Array.isArray(tmpl.args)) {
                tmpl.args.forEach((argName, index) => {
                  localContext[argName] = args[index] || "";
                });
              }
              return nunjucks.configure({ autoescape: false }).renderString(tmpl.template, localContext);
            };
          }
        });
      }

      try {
         console.log("Rendering",dot, context);
        let rendered = nunjucks.configure({ autoescape: false }).renderString(dot, context);
        console.log("Rendered nunjuchs",rendered);
        return rendered;
      } catch (err) {
        console.error("Error during nunjucks template rendering:", err);
        throw err
      }
    }
    
    function applyTemplateProcessing(dot) {
      dot = includeCommons(dot);
      dot = renderTemplatesInDot(dot);
      return dot;
    }
    
    function getGraphDot(graphName, visited = new Set()) {
      console.log("giving gprahDot", graphName)
      if (visited.has(graphName)) {
        console.warn("Cycle detected in includes for graph:", graphName);
        return "";
      }
      visited.add(graphName);
      const graphDef = graphMap[graphName];
      if (!graphDef) {
        console.warn("Graph", graphName, "not found.");
        return "";
      }
      let dotContent = "";
      if (graphDef.includes && Array.isArray(graphDef.includes)) {
        graphDef.includes.forEach(includeName => {
          dotContent += getGraphDot(includeName, visited) + "\n";
        });
      }
      if (graphDef.dot) {
        dotContent += graphDef.dot + "\n";
      }
      console.log("giving result graphdot", dotContent)
      return dotContent;
    }
    
    function ensureGraphWrapper(dot) {
      if (/^\s*(digraph|graph)\s*\{/.test(dot)) {
        return dot;
      } else {
        return "digraph {\n" + dot + "\n}";
      }
    }
    
    // Draggable divider code.
    const dragbar = document.getElementById("dragbar");
    const leftPane = document.getElementById("leftPane");
    let isDragging = false;

    dragbar.addEventListener("mousedown", function(e) {
      isDragging = true;
      document.body.style.cursor = "col-resize";
    });

    document.addEventListener("mousemove", function(e) {
      if (!isDragging) return;
      const containerOffsetLeft = document.querySelector('.container').offsetLeft;
      let newWidth = e.clientX - containerOffsetLeft;
      const minWidth = 150;
      const maxWidth = window.innerWidth - 150;
      if (newWidth < minWidth) newWidth = minWidth;
      if (newWidth > maxWidth) newWidth = maxWidth;
      leftPane.style.width = newWidth + "px";
    });

    document.addEventListener("mouseup", function() {
      if (isDragging) {
        isDragging = false;
        document.body.style.cursor = "default";
      }
    });
    
    // Global Variables.
    let yamlData = null;
    let graphMap = {};
    let animations = {};
    let monacoEditor = null;

    const graphviz = d3.select("#graph").graphviz().engine("neato").logEvents(true);

    let animationTimer = null;
    let isPlaying = false;
    let currentFrameIndex = 0;
    let currentAnimationFrames = [];
    let animationDelay = 1500;
    let isTransitioning = false;
    let yamlDebounceTimer = null;
  </script>
  
  <!-- Initialize Monaco Editor -->
  <script>
    require(['vs/editor/editor.main'], function() {
      monaco.languages.register({ id: 'yaml' });
      monacoEditor = monaco.editor.create(document.getElementById('yamlEditor'), {
        value: `---
graphs:
  - name: graph1
    dot: |-
        graph [pad="0.212,0.055" bgcolor=lightgray]
        fw -> ingress -> svc
        rs [pos = "-3,0!"]
        dp -> rs 
        dp [pos = "-5,0!"]
        {% set items = [ "poda", "podb", "podc" ] %}
        {% for item in items %}
        rs -> {{ item }}
        svc -> {{ item }}
        {{ item }} [ style=filled fillcolor="green"]
        {% endfor %}

  - name: graph2
    dot: |-
      # is a Jinja template
      # special function include should return dot content of graph1
      {{ include("graph1") }}



  - name: graph3
    dot: |-
      graph [pad="0.212,0.055" bgcolor=lightgray]
      node [style=filled]
      a [fillcolor="#d62728" pos="0,0!"]
      b [fillcolor="#1f77b4" pos="0,1!"]
      c [fillcolor="#2ca02c" pos="2,2!"]
      d [fillcolor="#ff7f0e" pos="-1,0!"]
      a -> b
      a -> c
      a -> d      

animation:
  - name: anim1
    graphs:
      - graph1
      - graph2

templates:
  - name: k8s.dp
    template: |-
      [label="{{ name }} - {{ namespace }}" ]
    args:
      - name
      - namespace
`,
        language: 'yaml',
        theme: 'vs-dark',
        automaticLayout: true
      });
      
      monacoEditor.onDidChangeModelContent(function() {
        clearTimeout(yamlDebounceTimer);
        yamlDebounceTimer = setTimeout(parseYaml, 500);
      });
      
      parseYaml();
    });
  </script>
  
  <!-- Application Logic -->
  <script>
    function parseYaml() {
      try {
        const doc = jsyaml.load(monacoEditor.getValue());
        yamlData = doc;
        
        graphMap = {};
        if (doc.graphs && Array.isArray(doc.graphs)) {
          doc.graphs.forEach(g => {
            if (g.name) {
              graphMap[g.name] = g;
            }
          });
        }
        
        commons = [];
        if (doc.commons && Array.isArray(doc.commons)) {
          commons = doc.commons;
        }
        
        templateFunctions = [];
        if (doc.templates && Array.isArray(doc.templates)) {
          templateFunctions = doc.templates;
        }
        
        animations = {};
        if (doc.animation && Array.isArray(doc.animation)) {
          doc.animation.forEach(anim => {
            if (anim.name && Array.isArray(anim.graphs)) {
              animations[anim.name] = anim.graphs;
            }
          });
        }
        
        if (!isPlaying) {
          pauseAnimation();
        }
        
        updateSelectionDropdown();
        
        if (document.getElementById('previewMode').value === "animation") {
          const animName = document.getElementById('itemSelector').value;
          currentAnimationFrames = animations[animName] || [];
          if (currentAnimationFrames.length === 0) {
            currentFrameIndex = 0;
          } else if (currentFrameIndex >= currentAnimationFrames.length) {
            currentFrameIndex = currentAnimationFrames.length - 1;
          }
          renderAnimationFrame(currentFrameIndex);
        } else {
          updatePreview();
        }
      } catch (e) {
        console.error("Error parsing YAML:", e);
      }
    }
    
    function updateSelectionDropdown() {
      const previewMode = document.getElementById('previewMode').value;
      const selectionContainer = document.getElementById('selectionContainer');
      
      let select = selectionContainer.querySelector('#itemSelector');
      let previousValue = null;
      if (select) {
        previousValue = select.value;
        select.innerHTML = "";
      } else {
        select = document.createElement('select');
        select.id = "itemSelector";
        select.classList.add("mdc-select__native-control");
      }
      
      if (previewMode === "graph") {
        document.getElementById('sliderContainer').style.display = "none";
        document.getElementById('animExtraControls').style.display = "none";
        for (let name in graphMap) {
          let option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          select.appendChild(option);
        }
      } else if (previewMode === "animation") {
        document.getElementById('sliderContainer').style.display = "inline-block";
        document.getElementById('animExtraControls').style.display = "block";
        for (let name in animations) {
          let option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          select.appendChild(option);
        }
      }
      
      if (previousValue && select.querySelector(`option[value="${previousValue}"]`)) {
        select.value = previousValue;
      }
      
      selectionContainer.innerHTML = "";
      const mdcSelectWrapper = document.createElement('div');
      mdcSelectWrapper.classList.add("mdc-select");
      mdcSelectWrapper.appendChild(select);
      selectionContainer.appendChild(mdcSelectWrapper);
      
      updatePreview();
    }
    
    function updatePreview() {
      if (document.getElementById('previewMode').value === "graph") {
        const itemSelector = document.getElementById('itemSelector');
        if (!itemSelector) return;
        const graphName = itemSelector.value;
        let dot = getGraphDot(graphName);
        console.log("got graph", dot)
        dot = applyTemplateProcessing(dot);
        console.log("got templated", dot)
        //dot = preprocessDot(dot);
        //console.log("got pre-processed", dot)
        dot = ensureGraphWrapper(dot);
        console.log("got wrapped", dot)
        isTransitioning = true;
        console.log("graphvizRender", dot)
        graphviz.renderDot(dot)
          .on("end", function () { isTransitioning = false; })
          .on("error", function(error) {
            isTransitioning = false;
            console.error("Graphviz render error:", error);
            document.getElementById("graph").innerHTML = "<div style='color:red;'>Graph rendering error. Please check your DOT input.</div>";
          });
      } else if (document.getElementById('previewMode').value === "animation") {
        const itemSelector = document.getElementById('itemSelector');
        if (!itemSelector) return;
        const animName = itemSelector.value;
        currentAnimationFrames = animations[animName] || [];
        const slider = document.getElementById('animSlider');
        slider.min = 0;
        slider.max = currentAnimationFrames.length > 0 ? currentAnimationFrames.length - 1 : 0;
        if (currentAnimationFrames.length > 0) {
          if (currentFrameIndex >= currentAnimationFrames.length) {
            currentFrameIndex = currentAnimationFrames.length - 1;
          }
          slider.value = currentFrameIndex;
          renderAnimationFrame(currentFrameIndex);
        } else {
          console.log("No frames in animation.");
        }
      }

    }
    
    function renderAnimationFrame(frameIndex) {
      if (!currentAnimationFrames || currentAnimationFrames.length === 0) {
        document.getElementById("graph").innerHTML = "No frames in animation.";
        return;
      }
      const graphName = currentAnimationFrames[frameIndex];
      let dot = getGraphDot(graphName);
      dot = applyTemplateProcessing(dot);
      dot = preprocessDot(dot);
      dot = ensureGraphWrapper(dot);
      document.getElementById("animSlider").value = frameIndex;
      isTransitioning = true;
      graphviz.renderDot(dot)
        .on("end", function () { isTransitioning = false; })
        .on("error", function(error) {
          isTransitioning = false;
          console.error("Graphviz render error:", error);
          document.getElementById("graph").innerHTML = "<div style='color:red;'>Graph rendering error. Please check your DOT input.</div>";
        });
    }
    
    function startAnimation() {
      if (isPlaying || currentAnimationFrames.length === 0) return;
      isPlaying = true;
      updateGraphvizTransition();
      scheduleNextFrame();
    }
    
    function scheduleNextFrame() {
      if (!isPlaying) return;
      const effectiveDelay = Math.max(animationDelay, 250);
      animationTimer = setTimeout(function () {
        if (!isPlaying) return;
        if (!isTransitioning) {
          nextAnimationFrame();
        }
        scheduleNextFrame();
      }, effectiveDelay);
    }
    
    function nextAnimationFrame() {
      currentFrameIndex++;
      if (currentFrameIndex >= currentAnimationFrames.length) {
        if (document.getElementById("loopCheckbox").checked) {
          currentFrameIndex = 0;
        } else {
          pauseAnimation();
          return;
        }
      }
      renderAnimationFrame(currentFrameIndex);
    }
    
    function pauseAnimation() {
      isPlaying = false;
      if (animationTimer) {
        clearTimeout(animationTimer);
        animationTimer = null;
      }
      updateGraphvizTransition();
    }
    
    function stopAnimation() {
      pauseAnimation();
      currentFrameIndex = 0;
      document.getElementById("animSlider").value = 0;
      renderAnimationFrame(currentFrameIndex);
    }
    
    function rewindAnimation() {
      pauseAnimation();
      currentFrameIndex = 0;
      document.getElementById("animSlider").value = 0;
      renderAnimationFrame(currentFrameIndex);
    }
    
    function updateDelay() {
      let newDelay = parseInt(document.getElementById("delaySlider").value);
      if (isNaN(newDelay) || newDelay < 250) {
        newDelay = 250;
        document.getElementById("delaySlider").value = newDelay;
      }
      animationDelay = newDelay;
      document.getElementById("delayValue").textContent = newDelay;
      if (isPlaying) {
        updateGraphvizTransition();
      }
    }
    
    function updateGraphvizTransition() {
      if (isPlaying) {
        graphviz.transition(function () {
          return d3.transition("auto")
                   .ease(d3.easeLinear)
                   .delay(animationDelay)
                   .duration(animationDelay);
        });
      } else {
        graphviz.transition(function () {
          return d3.transition("manual")
                   .ease(d3.easeLinear)
                   .delay(0)
                   .duration(0);
        });
      }
      
    }
    
    function downloadText(text, filename) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function downloadDot() {
      let dot = "";
      const previewMode = document.getElementById('previewMode').value;
      if (previewMode === "graph") {
        const graphName = document.getElementById('itemSelector').value;
        dot = getGraphDot(graphName);
      } else if (previewMode === "animation") {
        if (currentAnimationFrames.length === 0) {
          alert("No frames in the current animation.");
          return;
        }
        const graphName = currentAnimationFrames[currentFrameIndex];
        dot = getGraphDot(graphName);
      }
      dot = applyTemplateProcessing(dot);
      dot = preprocessDot(dot);
      dot = ensureGraphWrapper(dot);
      downloadText(dot, "graph.dot");
    }

    function downloadSvg() {
      const graphContainer = document.getElementById("graph");
      const svgElement = graphContainer.querySelector("svg");
      if (!svgElement) {
        alert("No SVG rendered yet.");
        return;
      }
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgElement);
      downloadText(svgString, "graph.svg");
    }
    
    document.getElementById("downloadDot").addEventListener("click", downloadDot);
    document.getElementById("downloadSvg").addEventListener("click", downloadSvg);
    
    document.getElementById('updateYaml').addEventListener('click', parseYaml);
    document.getElementById('previewMode').addEventListener('change', updateSelectionDropdown);
    
    document.getElementById('selectionContainer').addEventListener('change', function (e) {
      if (e.target && e.target.id === 'itemSelector') {
        updatePreview();
      }
    });
    
    document.getElementById('animSlider').addEventListener('input', function () {
      pauseAnimation();
      currentFrameIndex = parseInt(this.value);
      renderAnimationFrame(currentFrameIndex);
    });
    
    document.getElementById('playBtn').addEventListener('click', startAnimation);
    document.getElementById('pauseBtn').addEventListener('click', pauseAnimation);
    document.getElementById('stopBtn').addEventListener('click', stopAnimation);
    document.getElementById('rewindBtn').addEventListener('click', rewindAnimation);
    
    document.getElementById('delaySlider').addEventListener('input', updateDelay);
    
  </script> 
</body>
</html>

